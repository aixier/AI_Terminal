# AI Terminal 数据库设计方案

## 一、概述

本方案旨在规范AI Terminal后端数据存储架构，通过抽象数据层设计，实现从当前JSON文件存储向MySQL关系数据库和OSS对象存储的平滑迁移。

### 设计原则
1. **数据分离**: 结构化数据与非结构化数据分离存储
2. **可迁移性**: JSON文件模拟关系表，本地文件系统模拟对象存储
3. **向后兼容**: 保持现有API接口不变
4. **高性能**: 支持高并发访问和大文件存储

### 存储架构
- **关系数据库** (当前: JSON文件 → 未来: MySQL)
  - 用户信息、权限、任务状态等结构化数据
- **对象存储** (当前: 本地文件系统 → 未来: OSS/S3)
  - 生成的HTML、JSON、Markdown等文件

## 二、当前数据分析

### 2.1 已实现的数据类型

#### 用户数据 (userService.js:49-356)
- **存储位置**: `/data/users.json`
- **操作**: loadUsers(), saveUsers(), findUserByUsername(), findUserByToken()
- **字段**: id, username, password, token, displayName, email, status, createdAt, lastLogin

#### 用户工作空间 (userService.js:128-194)
- **存储位置**: `/data/users/{username}/`
- **结构**:
  - `settings.json`: 用户设置
  - `folders.json`: 文件夹组织
  - `workspace/card/`: 卡片文件目录
  - `workspace/markdown/`: Markdown文件目录

#### 模板数据 (templates.js:11-53)
- **存储位置**: `/data/public_template/`
- **类型**: 单文件模板(.md)、文件夹模板

#### 生成任务 (card.js:74-78, cardAsync.js:59)
- **当前状态**: 仅存在内存中 (activeRequests Map)
- **数据**: requestId, startTime, topic, templateName

#### 文件夹元数据 (workspaceMetadata.js:122-261)
- **存储位置**: 各用户文件夹内的 `_metadata.json`
- **操作**: updateFolderStatus(), recordGeneratedFiles()
- **字段**: status, templateName, createdAt, completedAt, files

### 2.2 缺失但需要的数据（补充设计）

#### 任务历史记录
- 当前没有持久化任务执行历史
- 需要记录: 请求参数、生成结果、执行时间、错误信息

#### 会话管理
- Terminal会话仅在内存中 (sessionManager.js:13)
- 需要持久化: sessionId, userId, createTime, lastActivity

#### API调用日志
- 当前无API调用记录
- 需要记录: 调用时间、用户、接口、参数、响应状态

## 三、数据库Schema设计

### 3.1 关系数据库表设计

#### users 表
```sql
-- 代码依据: userService.js:49-123
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,      -- 用户名
    password VARCHAR(255) NOT NULL,            -- 密码(应加密存储)
    token VARCHAR(255) UNIQUE,                 -- API访问令牌
    display_name VARCHAR(100),                 -- 显示名称
    email VARCHAR(100),                        -- 邮箱
    status ENUM('active','inactive','blocked') DEFAULT 'active',
    is_default BOOLEAN DEFAULT FALSE,          -- 是否默认用户
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP NULL,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_token (token),
    INDEX idx_username (username)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**JSON模拟文件**: `/data/db/users.json`
```json
{
  "table": "users",
  "auto_increment": 24,
  "rows": [
    {
      "id": 1,
      "username": "alice",
      "password": "alice123",
      "token": "alice-secure-token-abc123",
      "display_name": "Alice Wang",
      "email": "alice@example.com",
      "status": "active",
      "is_default": false,
      "created_at": "2024-01-01T00:00:00Z",
      "last_login": "2025-01-15T10:00:00Z",
      "updated_at": "2025-01-15T10:00:00Z"
    }
  ]
}
```

#### user_settings 表
```sql
-- 代码依据: userService.js:148-158
CREATE TABLE user_settings (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    theme VARCHAR(20) DEFAULT 'dark',
    language VARCHAR(10) DEFAULT 'zh-CN',
    auto_save BOOLEAN DEFAULT TRUE,
    default_workspace VARCHAR(50) DEFAULT 'workspace',
    settings_json JSON,                        -- 扩展设置
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE KEY uk_user_id (user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**JSON模拟文件**: `/data/db/user_settings.json`

#### templates 表
```sql
-- 代码依据: templates.js:11-53
CREATE TABLE templates (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) UNIQUE NOT NULL,         -- 模板名称
    display_name VARCHAR(200),                 -- 显示名称
    type ENUM('file','folder') NOT NULL,       -- 模板类型
    path VARCHAR(500),                         -- 存储路径(OSS)
    description TEXT,                           -- 模板描述
    category VARCHAR(50),                      -- 模板分类
    is_active BOOLEAN DEFAULT TRUE,            -- 是否启用
    usage_count INT DEFAULT 0,                 -- 使用次数
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_type (type),
    INDEX idx_category (category)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**JSON模拟文件**: `/data/db/templates.json`

#### generation_tasks 表
```sql
-- 代码依据: card.js:50-78, cardAsync.js:59-102
CREATE TABLE generation_tasks (
    id VARCHAR(50) PRIMARY KEY,                -- taskId/requestId
    user_id INT NOT NULL,
    type ENUM('sync','async','stream') NOT NULL,
    status ENUM('pending','processing','completed','failed','timeout') DEFAULT 'pending',
    topic VARCHAR(200) NOT NULL,               -- 生成主题
    template_id INT,                           -- 使用的模板
    request_params JSON,                       -- 原始请求参数
    generated_params JSON,                     -- Claude生成的参数
    error_message TEXT,                         -- 错误信息
    error_code VARCHAR(20),                    -- 错误代码
    retry_count INT DEFAULT 0,                 -- 重试次数
    start_time TIMESTAMP NULL,                 -- 开始处理时间
    end_time TIMESTAMP NULL,                   -- 结束时间
    duration_ms INT,                           -- 执行耗时(毫秒)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (template_id) REFERENCES templates(id),
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**JSON模拟文件**: `/data/db/generation_tasks.json`

#### generation_results 表
```sql
-- 代码依据: card.js:386-526, recordGeneratedFiles()
CREATE TABLE generation_results (
    id INT PRIMARY KEY AUTO_INCREMENT,
    task_id VARCHAR(50) NOT NULL,
    user_id INT NOT NULL,
    folder_path VARCHAR(500),                  -- 用户文件夹路径
    file_name VARCHAR(255),                    -- 主文件名
    file_type ENUM('json','html','markdown'),  -- 文件类型
    file_size INT,                             -- 文件大小(字节)
    file_path VARCHAR(500),                    -- OSS路径
    is_primary BOOLEAN DEFAULT FALSE,          -- 是否主文件
    metadata JSON,                              -- 额外元数据
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (task_id) REFERENCES generation_tasks(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    INDEX idx_task_id (task_id),
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**JSON模拟文件**: `/data/db/generation_results.json`

#### generation_metadata 表（新增）
```sql
-- 新增设计: 生成物元数据管理
CREATE TABLE generation_metadata (
    id INT PRIMARY KEY AUTO_INCREMENT,
    task_id VARCHAR(50) NOT NULL UNIQUE,       -- 关联任务ID
    user_id INT NOT NULL,                      -- 用户ID
    author_name VARCHAR(100),                  -- 作者名称
    author_id VARCHAR(50),                     -- 作者标识
    topic VARCHAR(200) NOT NULL,               -- 生成主题
    template_name VARCHAR(100),                -- 使用的模板名称
    template_version VARCHAR(20),              -- 模板版本
    generation_mode ENUM('sync','async','stream') NOT NULL, -- 生成方式
    generation_method VARCHAR(50),             -- 生成方法(claude-direct/api-terminal)
    ai_model VARCHAR(50),                      -- AI模型(claude-3-opus等)
    ai_provider VARCHAR(50) DEFAULT 'anthropic', -- AI提供商
    
    -- 参数记录
    input_params JSON,                         -- 输入参数(用户提供)
    generated_params JSON,                     -- 生成参数(AI生成)
    prompt_template TEXT,                      -- 使用的提示词模板
    
    -- 统计信息
    total_files INT DEFAULT 0,                 -- 生成文件总数
    primary_file_type VARCHAR(10),             -- 主文件类型
    total_size_bytes BIGINT DEFAULT 0,         -- 总文件大小
    generation_duration_ms INT,                -- 生成耗时(毫秒)
    
    -- 版本控制
    version INT DEFAULT 1,                     -- 版本号
    parent_task_id VARCHAR(50),                -- 父版本任务ID(用于追踪迭代)
    is_published BOOLEAN DEFAULT FALSE,        -- 是否已发布
    published_at TIMESTAMP NULL,               -- 发布时间
    
    -- 质量和反馈
    quality_score DECIMAL(3,2),                -- 质量评分(0-5)
    review_status ENUM('pending','approved','rejected','revised') DEFAULT 'pending',
    review_notes TEXT,                         -- 审核备注
    user_feedback TEXT,                        -- 用户反馈
    
    -- 标签和分类
    tags JSON,                                 -- 标签数组
    category VARCHAR(50),                      -- 分类
    language VARCHAR(10) DEFAULT 'zh-CN',      -- 内容语言
    style VARCHAR(50),                         -- 内容风格
    
    -- 时间戳
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NULL,                 -- 过期时间(用于临时内容)
    
    -- 索引
    FOREIGN KEY (task_id) REFERENCES generation_tasks(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (parent_task_id) REFERENCES generation_tasks(id),
    INDEX idx_user_id (user_id),
    INDEX idx_template_name (template_name),
    INDEX idx_created_at (created_at),
    INDEX idx_category (category),
    INDEX idx_review_status (review_status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**JSON模拟文件**: `/data/db/generation_metadata.json`

#### user_folders 表
```sql
-- 代码依据: folders.json结构
CREATE TABLE user_folders (
    id VARCHAR(50) PRIMARY KEY,                -- 文件夹ID
    user_id INT NOT NULL,
    name VARCHAR(200) NOT NULL,                -- 文件夹名称
    description TEXT,                           -- 描述
    color VARCHAR(20),                         -- 颜色标记
    parent_id VARCHAR(50),                     -- 父文件夹ID
    folder_type VARCHAR(20) DEFAULT 'card',    -- 文件夹类型
    file_count INT DEFAULT 0,                  -- 文件数量
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_user_id (user_id),
    INDEX idx_parent_id (parent_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**JSON模拟文件**: `/data/db/user_folders.json`

#### terminal_sessions 表（补充设计）
```sql
-- 补充设计: 基于sessionManager.js的需求
CREATE TABLE terminal_sessions (
    id VARCHAR(50) PRIMARY KEY,                -- sessionId
    user_id INT NOT NULL,
    type ENUM('terminal','claude','api') DEFAULT 'api',
    status ENUM('active','closed','timeout') DEFAULT 'active',
    client_ip VARCHAR(45),                     -- 客户端IP
    user_agent TEXT,                            -- User-Agent
    metadata JSON,                              -- 会话元数据
    last_activity TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    closed_at TIMESTAMP NULL,
    FOREIGN KEY (user_id) REFERENCES users(id),
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**JSON模拟文件**: `/data/db/terminal_sessions.json`

#### api_logs 表（补充设计）
```sql
-- 补充设计: API调用日志
CREATE TABLE api_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    session_id VARCHAR(50),
    endpoint VARCHAR(200) NOT NULL,            -- API端点
    method VARCHAR(10) NOT NULL,               -- HTTP方法
    request_params JSON,                       -- 请求参数
    response_code INT,                         -- 响应状态码
    response_time_ms INT,                      -- 响应时间
    error_message TEXT,                        -- 错误信息
    ip_address VARCHAR(45),                    -- 请求IP
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_id (user_id),
    INDEX idx_endpoint (endpoint),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**JSON模拟文件**: `/data/db/api_logs.json`

### 3.2 文件存储结构设计

#### 当前本地存储结构
```
/data/
├── db/                           # JSON数据库文件
│   ├── users.json
│   ├── user_settings.json
│   ├── templates.json
│   ├── generation_tasks.json
│   ├── generation_results.json
│   ├── user_folders.json
│   ├── terminal_sessions.json
│   └── api_logs.json
├── storage/                      # 模拟OSS对象存储
│   ├── templates/               # 模板文件
│   │   ├── single/             # 单文件模板
│   │   └── folder/             # 文件夹模板
│   ├── users/                  # 用户生成文件
│   │   └── {user_id}/
│   │       ├── workspace/
│   │       │   ├── card/       # 卡片文件
│   │       │   └── markdown/   # Markdown文件
│   │       └── temp/           # 临时文件
│   └── public/                 # 公共资源
└── cache/                       # 缓存目录
```

#### OSS对象存储映射
```
OSS Bucket Structure:
├── templates/                   # 模板文件
│   ├── {template_id}/
│   │   ├── template.md
│   │   └── resources/
├── generated/                   # 生成的文件
│   ├── {user_id}/
│   │   └── {task_id}/
│   │       ├── result.json
│   │       └── result.html
├── user-files/                 # 用户上传文件
│   └── {user_id}/
│       └── {file_id}
└── public/                     # 公共资源
    └── assets/
```

## 四、数据访问层设计

### 4.1 数据访问对象(DAO)接口

```javascript
// /data/dao/BaseDAO.js
class BaseDAO {
  constructor(tableName) {
    this.tableName = tableName;
    this.dbPath = `/data/db/${tableName}.json`;
  }

  async findById(id) {
    // 从JSON文件读取
  }

  async findAll(conditions = {}) {
    // 查询所有符合条件的记录
  }

  async create(data) {
    // 插入新记录
  }

  async update(id, data) {
    // 更新记录
  }

  async delete(id) {
    // 删除记录
  }

  async query(sql) {
    // 模拟SQL查询(未来直接执行)
  }
}

// /data/dao/UserDAO.js  
class UserDAO extends BaseDAO {
  constructor() {
    super('users');
  }

  async findByUsername(username) {
    // 代码依据: userService.js:98
    const users = await this.findAll({ username });
    return users[0] || null;
  }

  async findByToken(token) {
    // 代码依据: userService.js:113
    const users = await this.findAll({ token });
    return users[0] || null;
  }

  async updateLastLogin(userId) {
    // 代码依据: userService.js:84
    return this.update(userId, { 
      last_login: new Date().toISOString() 
    });
  }
}
```

### 4.2 对象存储服务接口

```javascript
// /data/storage/StorageService.js
class StorageService {
  constructor() {
    this.basePath = '/data/storage';
  }

  async uploadFile(key, content, metadata = {}) {
    // 上传文件到存储
    // 当前: 写入本地文件系统
    // 未来: 上传到OSS
  }

  async downloadFile(key) {
    // 下载文件
    // 当前: 读取本地文件
    // 未来: 从OSS下载
  }

  async deleteFile(key) {
    // 删除文件
  }

  async listFiles(prefix) {
    // 列出文件
  }

  async getFileUrl(key, expires = 3600) {
    // 获取文件访问URL
    // 当前: 返回本地路径
    // 未来: 生成OSS签名URL
  }
}
```

## 五、数据迁移策略

### 5.1 迁移步骤

1. **第一阶段**: 实现DAO层，保持现有JSON存储
   - 创建DAO接口和实现
   - 逐步替换直接文件操作为DAO调用
   - 保持API接口不变

2. **第二阶段**: 引入数据库连接池
   - 添加MySQL连接配置
   - 实现双写模式(JSON+MySQL)
   - 数据一致性验证

3. **第三阶段**: 切换到MySQL
   - 数据迁移脚本执行
   - 切换读操作到MySQL
   - 保留JSON作为备份

4. **第四阶段**: 对象存储迁移
   - 配置OSS服务
   - 实现文件上传到OSS
   - 更新文件访问路径

### 5.2 兼容性保证

```javascript
// 配置文件 config/database.js
module.exports = {
  // 数据库模式: 'json' | 'mysql' | 'dual'
  mode: process.env.DB_MODE || 'json',
  
  mysql: {
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'ai_terminal'
  },
  
  storage: {
    // 存储模式: 'local' | 'oss' | 'dual'
    mode: process.env.STORAGE_MODE || 'local',
    
    oss: {
      accessKeyId: process.env.OSS_ACCESS_KEY_ID,
      accessKeySecret: process.env.OSS_ACCESS_KEY_SECRET,
      bucket: process.env.OSS_BUCKET,
      region: process.env.OSS_REGION
    }
  }
};
```

### 5.3 数据一致性保证

1. **事务支持**: 使用数据库事务保证操作原子性
2. **数据验证**: 迁移前后数据完整性校验
3. **回滚机制**: 保留原始数据，支持快速回滚
4. **增量同步**: 支持增量数据同步，减少停机时间

## 六、监控与维护

### 6.1 监控指标

- 数据库连接数
- 查询响应时间
- 存储使用量
- API调用频率
- 错误率统计

### 6.2 数据备份策略

```javascript
// 备份配置
{
  "backup": {
    "enabled": true,
    "schedule": "0 2 * * *",  // 每天凌晨2点
    "retention": 30,           // 保留30天
    "destinations": [
      {
        "type": "local",
        "path": "/backup/db"
      },
      {
        "type": "oss",
        "bucket": "ai-terminal-backup"
      }
    ]
  }
}
```

## 七、安全考虑

1. **敏感数据加密**
   - 密码使用bcrypt加密
   - Token使用JWT签名
   - 传输使用HTTPS

2. **访问控制**
   - 基于角色的权限控制
   - API限流防护
   - SQL注入防护

3. **审计日志**
   - 记录所有数据变更
   - 保留操作历史
   - 异常行为检测

## 八、性能优化

### 8.1 缓存策略

```javascript
// Redis缓存配置
{
  "cache": {
    "enabled": true,
    "redis": {
      "host": "localhost",
      "port": 6379,
      "ttl": 3600
    },
    "keys": {
      "user": "user:{id}",
      "template": "template:{id}",
      "task": "task:{id}"
    }
  }
}
```

### 8.2 查询优化

1. **索引设计**: 基于查询模式创建合适索引
2. **分页查询**: 大数据集使用游标分页
3. **异步处理**: 耗时操作使用消息队列
4. **连接池**: 复用数据库连接

## 九、实施计划

### 第1周: 基础架构搭建
- [ ] 创建DAO层框架
- [ ] 实现BaseDAO基类
- [ ] 创建JSON数据库文件结构

### 第2周: 核心功能迁移
- [ ] 实现UserDAO
- [ ] 实现TaskDAO
- [ ] 实现StorageService

### 第3周: 测试与优化
- [ ] 单元测试编写
- [ ] 性能测试
- [ ] 接口兼容性测试

### 第4周: 文档与部署
- [ ] API文档更新
- [ ] 部署指南
- [ ] 运维手册

## 十、风险评估

| 风险项 | 影响程度 | 发生概率 | 缓解措施 |
|--------|----------|----------|----------|
| 数据迁移失败 | 高 | 低 | 完整备份，分批迁移 |
| 性能下降 | 中 | 中 | 缓存优化，查询优化 |
| 兼容性问题 | 高 | 低 | 充分测试，灰度发布 |
| 存储成本增加 | 低 | 高 | 成本预算，存储优化 |

## 十一、总结

本方案通过抽象数据访问层，实现了从JSON文件存储向关系数据库和对象存储的平滑过渡。设计充分考虑了现有代码的兼容性，确保在不影响业务的情况下完成架构升级。通过分阶段实施，降低了迁移风险，提高了系统的可扩展性和可维护性。

### 关键优势
1. **零停机迁移**: 双写模式保证服务连续性
2. **向后兼容**: API接口保持不变
3. **易于回滚**: 保留原始数据结构
4. **可扩展性**: 支持未来功能扩展

### 后续优化方向
1. 引入GraphQL提升API灵活性
2. 实现读写分离提高性能
3. 添加数据分析和BI功能
4. 支持多租户架构

## 十二、生成物元数据管理详细方案

### 12.1 元数据管理的重要性

生成物元数据是系统的核心资产，它记录了：
- **Who**: 谁生成的内容（用户、作者信息）
- **What**: 生成了什么（主题、文件类型、内容分类）
- **When**: 何时生成（创建时间、更新时间、发布时间）
- **How**: 如何生成（模板、参数、AI模型、生成方式）
- **Why**: 为什么生成（用途、标签、分类）

### 12.2 元数据JSON完整示例

```json
{
  "table": "generation_metadata",
  "auto_increment": 100,
  "rows": [
    {
      "id": 1,
      "task_id": "task_1234567890_abc123",
      "user_id": 1,
      "author_name": "Alice Wang",
      "author_id": "alice",
      "topic": "人工智能基础知识",
      "template_name": "daily-knowledge-card-template.md",
      "template_version": "1.0.0",
      "generation_mode": "async",
      "generation_method": "claude-direct",
      "ai_model": "claude-3-opus-20240229",
      "ai_provider": "anthropic",
      "input_params": {
        "style": "专业科技风",
        "language": "中文",
        "reference": "参考内容..."
      },
      "generated_params": {
        "style": "专业严谨，深入浅出",
        "language": "简体中文",
        "reference": "基于深度学习原理..."
      },
      "prompt_template": "根据[${templatePath}]文档的规范...",
      "total_files": 2,
      "primary_file_type": "json",
      "total_size_bytes": 30720,
      "generation_duration_ms": 15000,
      "version": 1,
      "parent_task_id": null,
      "is_published": false,
      "published_at": null,
      "quality_score": 4.5,
      "review_status": "approved",
      "review_notes": "内容准确，表达清晰",
      "user_feedback": "非常有帮助的内容",
      "tags": ["AI", "知识卡片", "科普", "深度学习"],
      "category": "technology",
      "language": "zh-CN",
      "style": "professional",
      "created_at": "2025-01-20T10:00:00Z",
      "updated_at": "2025-01-20T10:00:15Z",
      "expires_at": null
    }
  ]
}
```

### 12.3 元数据DAO完整实现

```javascript
// /data/dao/GenerationMetadataDAO.js
class GenerationMetadataDAO extends BaseDAO {
  constructor() {
    super('generation_metadata');
  }

  // 创建元数据记录
  async createMetadata(taskId, data) {
    const metadata = {
      task_id: taskId,
      user_id: data.userId,
      author_name: data.authorName || data.username,
      author_id: data.authorId || data.username,
      topic: data.topic,
      template_name: data.templateName,
      template_version: data.templateVersion || '1.0.0',
      generation_mode: data.generationMode,
      generation_method: data.generationMethod || 'claude-direct',
      ai_model: data.aiModel || 'claude-3-opus',
      ai_provider: 'anthropic',
      input_params: data.inputParams,
      generated_params: data.generatedParams,
      prompt_template: data.promptTemplate,
      tags: data.tags || this.extractTags(data.topic),
      category: data.category || this.determineCategory(data.topic),
      language: data.language || 'zh-CN',
      style: data.style,
      created_at: new Date().toISOString()
    };
    return this.create(metadata);
  }

  // 更新生成结果
  async updateGenerationResult(taskId, resultData) {
    return this.update(taskId, {
      total_files: resultData.totalFiles,
      primary_file_type: resultData.primaryFileType,
      total_size_bytes: resultData.totalSizeBytes,
      generation_duration_ms: resultData.durationMs,
      updated_at: new Date().toISOString()
    });
  }

  // 按用户查询
  async findByUser(userId, options = {}) {
    const conditions = { user_id: userId };
    
    if (options.templateName) conditions.template_name = options.templateName;
    if (options.category) conditions.category = options.category;
    if (options.reviewStatus) conditions.review_status = options.reviewStatus;
    
    if (options.startDate && options.endDate) {
      conditions.created_at = { 
        $gte: options.startDate, 
        $lte: options.endDate 
      };
    }
    
    if (options.tags && options.tags.length > 0) {
      conditions.tags = { $in: options.tags };
    }
    
    return this.findAll(conditions);
  }

  // 更新审核状态
  async updateReviewStatus(taskId, status, notes, score) {
    const updateData = {
      review_status: status,
      review_notes: notes,
      updated_at: new Date().toISOString()
    };
    
    if (score !== undefined) {
      updateData.quality_score = score;
    }
    
    return this.update(taskId, updateData);
  }

  // 获取统计信息
  async getStatistics(userId, period = 'all') {
    let dateFilter = {};
    const now = new Date();
    
    switch (period) {
      case 'day':
        dateFilter = { 
          created_at: { 
            $gte: new Date(now - 24 * 60 * 60 * 1000).toISOString() 
          }
        };
        break;
      case 'week':
        dateFilter = { 
          created_at: { 
            $gte: new Date(now - 7 * 24 * 60 * 60 * 1000).toISOString() 
          }
        };
        break;
      case 'month':
        dateFilter = { 
          created_at: { 
            $gte: new Date(now - 30 * 24 * 60 * 60 * 1000).toISOString() 
          }
        };
        break;
    }
    
    const allMetadata = await this.findAll({ 
      user_id: userId, 
      ...dateFilter 
    });
    
    return {
      total_generations: allMetadata.length,
      total_size: allMetadata.reduce((sum, m) => sum + (m.total_size_bytes || 0), 0),
      average_duration: allMetadata.length > 0 
        ? allMetadata.reduce((sum, m) => sum + (m.generation_duration_ms || 0), 0) / allMetadata.length 
        : 0,
      templates_used: [...new Set(allMetadata.map(m => m.template_name))],
      categories: [...new Set(allMetadata.map(m => m.category))],
      success_rate: allMetadata.length > 0
        ? allMetadata.filter(m => m.review_status === 'approved').length / allMetadata.length
        : 0,
      average_quality: allMetadata.length > 0
        ? allMetadata.reduce((sum, m) => sum + (m.quality_score || 0), 0) / allMetadata.length
        : 0
    };
  }

  // 智能标签提取
  extractTags(topic) {
    const tags = [];
    
    // AI相关关键词
    if (topic.match(/AI|人工智能|机器学习|深度学习|神经网络/i)) {
      tags.push('AI');
    }
    
    // 技术相关
    if (topic.match(/编程|代码|开发|技术|算法/i)) {
      tags.push('技术');
    }
    
    // 科普相关
    if (topic.match(/科普|知识|教程|入门|基础/i)) {
      tags.push('科普');
    }
    
    return tags;
  }

  // 智能分类判断
  determineCategory(topic) {
    if (topic.match(/技术|编程|开发|代码|算法/i)) return 'technology';
    if (topic.match(/生活|日常|健康|美食/i)) return 'lifestyle';
    if (topic.match(/教育|学习|知识|科普/i)) return 'education';
    if (topic.match(/商业|经济|创业|管理/i)) return 'business';
    if (topic.match(/艺术|设计|创意|文化/i)) return 'creative';
    return 'general';
  }
}
```

### 12.4 元数据收集集成代码

```javascript
// 在生成请求处理中集成元数据收集
// /routes/generate/card.js 集成示例

const metadataDAO = new GenerationMetadataDAO();

router.post('/', authenticateUserOrDefault, ensureUserFolder, async (req, res) => {
  const requestId = `card_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
  const requestStartTime = Date.now();
  
  try {
    const { topic, templateName, style, language, reference, token } = req.body;
    
    // 1. 创建初始元数据
    await metadataDAO.createMetadata(requestId, {
      userId: req.user.id,
      username: req.user.username,
      topic: topic,
      templateName: templateName,
      generationMode: 'sync',
      generationMethod: 'claude-direct',
      inputParams: {
        style: style,
        language: language,
        reference: reference
      }
    });
    
    // 2. 生成参数
    const parameters = await claudeExecutorDirect.generateCardParameters(topic, templateName, {
      style: style,
      language: language,
      reference: reference
    });
    
    // 3. 更新生成参数
    await metadataDAO.update(requestId, {
      generated_params: parameters,
      prompt_template: prompt // 保存使用的提示词
    });
    
    // 4. 执行生成...
    const result = await generateContent();
    
    // 5. 更新生成结果元数据
    await metadataDAO.updateGenerationResult(requestId, {
      totalFiles: result.files.length,
      primaryFileType: result.fileType,
      totalSizeBytes: calculateFileSize(result),
      durationMs: Date.now() - requestStartTime
    });
    
    res.json({ 
      success: true, 
      taskId: requestId, 
      result: result,
      metadata: {
        duration: Date.now() - requestStartTime,
        taskId: requestId
      }
    });
    
  } catch (error) {
    // 记录失败
    await metadataDAO.updateReviewStatus(requestId, 'failed', error.message);
    throw error;
  }
});
```

### 12.5 元数据查询API实现

```javascript
// /routes/metadata.js
const express = require('express');
const router = express.Router();
const metadataDAO = new GenerationMetadataDAO();

// 获取用户统计信息
router.get('/statistics/:userId', async (req, res) => {
  const { period = 'month' } = req.query;
  const stats = await metadataDAO.getStatistics(req.params.userId, period);
  
  res.json({
    code: 200,
    success: true,
    data: stats
  });
});

// 搜索元数据
router.get('/search', async (req, res) => {
  const { 
    userId, 
    templateName, 
    category, 
    tags, 
    startDate, 
    endDate,
    reviewStatus,
    page = 1,
    pageSize = 20
  } = req.query;
  
  const results = await metadataDAO.findByUser(userId, {
    templateName,
    category,
    tags: tags ? tags.split(',') : undefined,
    startDate,
    endDate,
    reviewStatus
  });
  
  // 分页
  const start = (page - 1) * pageSize;
  const end = start + pageSize;
  const paginatedResults = results.slice(start, end);
  
  res.json({
    code: 200,
    success: true,
    data: paginatedResults,
    pagination: {
      page: parseInt(page),
      pageSize: parseInt(pageSize),
      total: results.length,
      totalPages: Math.ceil(results.length / pageSize)
    }
  });
});

// 获取单个任务元数据
router.get('/task/:taskId', async (req, res) => {
  const metadata = await metadataDAO.findById(req.params.taskId);
  
  if (!metadata) {
    return res.status(404).json({
      code: 404,
      success: false,
      message: 'Metadata not found'
    });
  }
  
  res.json({
    code: 200,
    success: true,
    data: metadata
  });
});

// 更新审核状态
router.put('/task/:taskId/review', async (req, res) => {
  const { status, notes, score } = req.body;
  
  await metadataDAO.updateReviewStatus(
    req.params.taskId, 
    status, 
    notes, 
    score
  );
  
  res.json({
    code: 200,
    success: true,
    message: 'Review status updated'
  });
});

// 批量导出元数据
router.get('/export', async (req, res) => {
  const { userId, format = 'json', startDate, endDate } = req.query;
  
  const metadata = await metadataDAO.findByUser(userId, {
    startDate,
    endDate
  });
  
  if (format === 'csv') {
    // CSV格式导出
    const csv = convertToCSV(metadata);
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename="metadata.csv"');
    res.send(csv);
  } else {
    // JSON格式导出
    res.json({
      code: 200,
      success: true,
      data: metadata,
      exportDate: new Date().toISOString()
    });
  }
});

module.exports = router;
```

### 12.6 元数据维护和优化

```javascript
// /services/metadataMaintenanceService.js

class MetadataMaintenanceService {
  constructor() {
    this.metadataDAO = new GenerationMetadataDAO();
    this.storageService = new StorageService();
  }

  // 归档旧元数据
  async archiveOldMetadata(daysToKeep = 90) {
    const cutoffDate = new Date(Date.now() - daysToKeep * 24 * 60 * 60 * 1000);
    
    const oldMetadata = await this.metadataDAO.findAll({
      created_at: { $lt: cutoffDate.toISOString() }
    });
    
    for (const metadata of oldMetadata) {
      // 归档到对象存储
      const archiveKey = `archive/metadata/${metadata.user_id}/${metadata.task_id}.json`;
      await this.storageService.uploadFile(
        archiveKey, 
        JSON.stringify(metadata), 
        {
          contentType: 'application/json',
          archived: true,
          archivedAt: new Date().toISOString()
        }
      );
      
      // 从主表删除
      await this.metadataDAO.delete(metadata.id);
    }
    
    console.log(`Archived ${oldMetadata.length} metadata records`);
    return oldMetadata.length;
  }

  // 清理无效元数据
  async cleanupInvalidMetadata() {
    // 清理没有对应文件的元数据
    const allMetadata = await this.metadataDAO.findAll();
    let cleanedCount = 0;
    
    for (const metadata of allMetadata) {
      const fileExists = await this.checkFilesExist(metadata);
      if (!fileExists) {
        await this.metadataDAO.updateReviewStatus(
          metadata.task_id,
          'invalid',
          'Generated files not found'
        );
        cleanedCount++;
      }
    }
    
    return cleanedCount;
  }

  // 检查文件是否存在
  async checkFilesExist(metadata) {
    try {
      const key = `generated/${metadata.user_id}/${metadata.task_id}/`;
      const files = await this.storageService.listFiles(key);
      return files && files.length > 0;
    } catch (error) {
      return false;
    }
  }

  // 重建元数据索引
  async rebuildIndexes() {
    // 这里可以实现索引重建逻辑
    // 在迁移到MySQL后会用到
    console.log('Rebuilding metadata indexes...');
  }
}

// 定时任务
const maintenanceService = new MetadataMaintenanceService();

// 每天凌晨2点执行归档
schedule.scheduleJob('0 2 * * *', async () => {
  await maintenanceService.archiveOldMetadata();
});

// 每周日凌晨3点清理无效数据
schedule.scheduleJob('0 3 * * 0', async () => {
  await maintenanceService.cleanupInvalidMetadata();
});
```

### 12.7 元数据使用最佳实践

1. **必须收集的元数据**：
   - 任务ID、用户信息
   - 生成时间、耗时
   - 使用的模板和参数
   - 生成文件信息

2. **可选但推荐的元数据**：
   - 质量评分
   - 用户反馈
   - 标签和分类
   - 版本信息

3. **性能优化建议**：
   - 使用索引加速查询
   - 定期归档旧数据
   - 缓存热点数据
   - 异步收集非关键元数据

4. **安全和隐私**：
   - 不存储敏感信息
   - 提示词脱敏处理
   - 访问权限控制
   - 定期清理过期数据

## 十二、生成物元数据管理补充说明

### 12.1 元数据JSON示例

**generation_metadata.json 完整示例**:
```json
{
  "table": "generation_metadata",
  "auto_increment": 1,
  "rows": [
    {
      "id": 1,
      "task_id": "task_1234567890_abc123",
      "user_id": 1,
      "author_name": "Alice Wang",
      "author_id": "alice",
      "topic": "人工智能基础知识",
      "template_name": "daily-knowledge-card-template.md",
      "template_version": "1.0.0",
      "generation_mode": "async",
      "generation_method": "claude-direct",
      "ai_model": "claude-3-opus-20240229",
      "ai_provider": "anthropic",
      "input_params": {
        "style": "专业科技风",
        "language": "中文",
        "reference": "参考内容..."
      },
      "generated_params": {
        "style": "专业严谨，深入浅出",
        "language": "简体中文",
        "reference": "基于深度学习原理..."
      },
      "prompt_template": "根据[${templatePath}]文档的规范...",
      "total_files": 2,
      "primary_file_type": "json",
      "total_size_bytes": 30720,
      "generation_duration_ms": 15000,
      "version": 1,
      "parent_task_id": null,
      "is_published": false,
      "published_at": null,
      "quality_score": 4.5,
      "review_status": "approved",
      "review_notes": "内容准确，表达清晰",
      "user_feedback": "非常有帮助的内容",
      "tags": ["AI", "知识卡片", "科普", "深度学习"],
      "category": "technology",
      "language": "zh-CN",
      "style": "professional",
      "created_at": "2025-01-20T10:00:00Z",
      "updated_at": "2025-01-20T10:00:15Z",
      "expires_at": null
    }
  ]
}
```

### 12.2 元数据DAO实现

```javascript
// /data/dao/GenerationMetadataDAO.js
class GenerationMetadataDAO extends BaseDAO {
  constructor() {
    super('generation_metadata');
  }

  async createMetadata(taskId, data) {
    const metadata = {
      task_id: taskId,
      user_id: data.userId,
      author_name: data.authorName || data.username,
      author_id: data.authorId || data.username,
      topic: data.topic,
      template_name: data.templateName,
      template_version: data.templateVersion || '1.0.0',
      generation_mode: data.generationMode,
      generation_method: data.generationMethod || 'claude-direct',
      ai_model: data.aiModel || 'claude-3-opus',
      ai_provider: 'anthropic',
      input_params: data.inputParams,
      generated_params: data.generatedParams,
      prompt_template: data.promptTemplate,
      tags: data.tags || [],
      category: data.category,
      language: data.language || 'zh-CN',
      style: data.style,
      created_at: new Date().toISOString()
    };
    return this.create(metadata);
  }

  async updateGenerationResult(taskId, resultData) {
    return this.update(taskId, {
      total_files: resultData.totalFiles,
      primary_file_type: resultData.primaryFileType,
      total_size_bytes: resultData.totalSizeBytes,
      generation_duration_ms: resultData.durationMs,
      updated_at: new Date().toISOString()
    });
  }

  async findByUser(userId, options = {}) {
    const conditions = { user_id: userId };
    if (options.templateName) conditions.template_name = options.templateName;
    if (options.category) conditions.category = options.category;
    if (options.startDate && options.endDate) {
      // 日期范围查询
      conditions.created_at = { 
        $gte: options.startDate, 
        $lte: options.endDate 
      };
    }
    return this.findAll(conditions);
  }

  async updateReviewStatus(taskId, status, notes) {
    return this.update(taskId, {
      review_status: status,
      review_notes: notes,
      updated_at: new Date().toISOString()
    });
  }

  async getStatistics(userId) {
    // 获取用户统计信息
    const allMetadata = await this.findByUser(userId);
    return {
      total_generations: allMetadata.length,
      total_size: allMetadata.reduce((sum, m) => sum + (m.total_size_bytes || 0), 0),
      average_duration: allMetadata.reduce((sum, m) => sum + (m.generation_duration_ms || 0), 0) / allMetadata.length,
      templates_used: [...new Set(allMetadata.map(m => m.template_name))],
      categories: [...new Set(allMetadata.map(m => m.category))]
    };
  }
}
```

### 12.3 元数据收集集成示例

```javascript
// 在 card.js 中集成元数据收集
async function handleGenerationRequest(req, res) {
  const taskId = `task_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
  const metadataDAO = new GenerationMetadataDAO();
  
  // 1. 创建初始元数据
  await metadataDAO.createMetadata(taskId, {
    userId: req.user.id,
    username: req.user.username,
    topic: req.body.topic,
    templateName: req.body.templateName,
    generationMode: 'async',
    inputParams: {
      style: req.body.style,
      language: req.body.language,
      reference: req.body.reference
    },
    category: determineCategory(req.body.topic),
    tags: extractTags(req.body.topic)
  });
  
  const startTime = Date.now();
  
  try {
    // 2. 执行生成
    const result = await generateContent(req.body);
    
    // 3. 更新生成结果元数据
    await metadataDAO.updateGenerationResult(taskId, {
      totalFiles: result.files.length,
      primaryFileType: result.primaryType,
      totalSizeBytes: calculateTotalSize(result.files),
      durationMs: Date.now() - startTime
    });
    
    res.json({ success: true, taskId, result });
  } catch (error) {
    // 记录错误
    await metadataDAO.update(taskId, {
      review_status: 'failed',
      review_notes: error.message
    });
    throw error;
  }
}
```

### 12.4 元数据查询API

```javascript
// GET /api/metadata/statistics/:userId
router.get('/statistics/:userId', async (req, res) => {
  const metadataDAO = new GenerationMetadataDAO();
  const stats = await metadataDAO.getStatistics(req.params.userId);
  
  res.json({
    code: 200,
    success: true,
    data: {
      overview: stats,
      recent_generations: await metadataDAO.findByUser(req.params.userId, {
        startDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // 最近7天
        endDate: new Date()
      }),
      popular_templates: await getPopularTemplates(req.params.userId),
      quality_metrics: await getQualityMetrics(req.params.userId)
    }
  });
});

// GET /api/metadata/search
router.get('/search', async (req, res) => {
  const { userId, templateName, category, tags, startDate, endDate } = req.query;
  const metadataDAO = new GenerationMetadataDAO();
  
  const results = await metadataDAO.findAll({
    user_id: userId,
    template_name: templateName,
    category: category,
    tags: tags ? { $in: tags.split(',') } : undefined,
    created_at: startDate && endDate ? { 
      $gte: startDate, 
      $lte: endDate 
    } : undefined
  });
  
  res.json({
    code: 200,
    success: true,
    data: results,
    total: results.length
  });
});
```

### 12.5 元数据存储优化

```javascript
// 定期归档旧元数据
async function archiveOldMetadata() {
  const metadataDAO = new GenerationMetadataDAO();
  const storageService = new StorageService();
  
  // 获取30天前的元数据
  const cutoffDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
  const oldMetadata = await metadataDAO.findAll({
    created_at: { $lt: cutoffDate.toISOString() }
  });
  
  // 归档到对象存储
  for (const metadata of oldMetadata) {
    const archiveKey = `archive/metadata/${metadata.user_id}/${metadata.task_id}.json`;
    await storageService.uploadFile(archiveKey, JSON.stringify(metadata), {
      contentType: 'application/json',
      archived: true
    });
    
    // 从主表删除
    await metadataDAO.delete(metadata.id);
  }
  
  console.log(`Archived ${oldMetadata.length} metadata records`);
}

// 定时任务
setInterval(archiveOldMetadata, 24 * 60 * 60 * 1000); // 每天执行一次
```

### 12.6 元数据报表功能

```javascript
// 生成月度报表
async function generateMonthlyReport(userId, month, year) {
  const metadataDAO = new GenerationMetadataDAO();
  const startDate = new Date(year, month - 1, 1);
  const endDate = new Date(year, month, 0);
  
  const metadata = await metadataDAO.findByUser(userId, {
    startDate,
    endDate
  });
  
  return {
    period: `${year}-${month.toString().padStart(2, '0')}`,
    summary: {
      total_generations: metadata.length,
      successful: metadata.filter(m => m.review_status === 'approved').length,
      failed: metadata.filter(m => m.review_status === 'failed').length,
      pending: metadata.filter(m => m.review_status === 'pending').length
    },
    by_template: groupBy(metadata, 'template_name'),
    by_category: groupBy(metadata, 'category'),
    performance: {
      average_duration: average(metadata.map(m => m.generation_duration_ms)),
      total_size: sum(metadata.map(m => m.total_size_bytes)),
      quality_score: average(metadata.map(m => m.quality_score).filter(Boolean))
    },
    top_topics: getTopTopics(metadata, 10),
    daily_trend: getDailyTrend(metadata)
  };
}
```