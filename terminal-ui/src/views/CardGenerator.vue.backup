<template>
  <div class="card-generator-layout">
    <!-- Left Sidebar - My Cards -->
    <div class="left-sidebar">
      <div class="sidebar-header">
        <span class="sidebar-title">æˆ‘çš„å¡ç‰‡</span>
        <button class="refresh-btn" @click="refreshCardFolders" title="åˆ·æ–°">
          ğŸ”„
        </button>
      </div>
      <div class="folder-tree">
        <div 
          v-for="folder in cardFolders" 
          :key="folder.id"
          class="folder-container"
        >
          <div 
            class="folder-item"
            :class="{ expanded: expandedFolders.includes(folder.id) }"
            @click="toggleFolder(folder.id)"
          >
            <span class="folder-icon">{{ expandedFolders.includes(folder.id) ? 'ğŸ“‚' : 'ğŸ“' }}</span>
            <span class="folder-name">{{ folder.name }}</span>
            <span class="folder-count">({{ folder.cards?.length || 0 }})</span>
          </div>
          
          <div v-if="expandedFolders.includes(folder.id)" class="cards-list">
            <div 
              v-for="card in folder.cards" 
              :key="card.id"
              class="card-item"
              :class="{ active: selectedCard === card.id }"
              @click="selectCard(card.id, folder.id)"
            >
              <span class="card-icon">
                {{ getFileIcon(card.name) }}
              </span>
              <span class="card-name">{{ card.name }}</span>
              <div class="card-actions">
                <span class="card-type">{{ getFileType(card.name) }}</span>
                <button 
                  v-if="card.name.toLowerCase().endsWith('.json')"
                  class="generate-html-btn"
                  @click.stop="generateHtmlFromJson(card, folder)"
                  :disabled="isGeneratingHtml[card.id]"
                  title="é¢„è§ˆHTML"
                >
                  <svg v-if="!isGeneratingHtml[card.id]" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                    <path d="M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5h-2z"/>
                    <path d="M8.646 6.646a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1 0 .708l-2 2a.5.5 0 0 1-.708-.708L10.293 9 8.646 7.354a.5.5 0 0 1 0-.708z"/>
                  </svg>
                  <span v-else class="loading-spinner">âŸ³</span>
                </button>
              </div>
            </div>
          </div>
        </div>
        
        <div v-if="cardFolders.length === 0" class="empty-message">
          æš‚æ— å¡ç‰‡æ–‡ä»¶å¤¹
        </div>
      </div>
    </div>

    <!-- Main Content Area -->
    <div class="main-area">
      <!-- Top: Card Preview Area -->
      <div class="preview-area">
        <div class="area-title">
          {{ selectedCard ? 'å¡ç‰‡å†…å®¹é¢„è§ˆ' : 'ç”Ÿæˆç»“æœé¢„è§ˆ' }}
          <span v-if="selectedCard && previewType" class="preview-type-tag">{{ previewType.toUpperCase() }}</span>
        </div>
        <div class="preview-content">
          <!-- HTMLæ–‡ä»¶æˆ–iframe URLé¢„è§ˆ -->
          <iframe 
            v-if="previewContent && (previewType === 'html' || previewType === 'iframe')"
            :src="previewContent"
            class="preview-iframe"
            frameborder="0"
            sandbox="allow-same-origin allow-scripts allow-forms allow-popups"
            referrerpolicy="no-referrer"
          ></iframe>
          
          <!-- JSONæ–‡ä»¶ä½¿ç”¨éªŒè¯JSONæŸ¥çœ‹å™¨ -->
          <ValidatedJsonViewer 
            v-else-if="previewContent && previewType === 'json'"
            :data="previewContent"
            class="json-viewer-preview"
            @fixed="handleJsonFixed"
            @preview="handleJsonPreview"
          />
          
          <!-- é»˜è®¤å†…å®¹ -->
          <div v-else class="empty-state">
            {{ selectedCard ? 'åŠ è½½å¡ç‰‡å†…å®¹...' : 'ç­‰å¾…ç”Ÿæˆå¡ç‰‡...' }}
          </div>
        </div>
      </div>

      <!-- Bottom: Terminal Area (å¯æŠ˜å ) -->
      <div class="terminal-area" :class="{ collapsed: !showTerminal }">
        <div class="terminal-header" @click="showTerminal = !showTerminal">
          <span class="terminal-title">
            <span class="terminal-toggle">{{ showTerminal ? 'â–¼' : 'â–¶' }}</span>
            terminal
            <span v-if="!showTerminal" class="terminal-status-mini">
              {{ isClaudeInitialized ? 'âœ… Claudeå°±ç»ª' : isInitializingClaude ? 'ğŸ”„ åˆå§‹åŒ–ä¸­...' : 'âšª æœªåˆå§‹åŒ–' }}
            </span>
          </span>
          <div class="terminal-actions" v-if="showTerminal">
            <!-- æµå¼çŠ¶æ€æŒ‡ç¤ºå™¨ -->
            <div v-if="streamingStatus.isStreaming" class="streaming-indicator">
              <span class="streaming-dot"></span>
              <span>æ¥æ”¶ä¸­... ({{ Math.round(streamingStatus.bufferLength / 1024) }}KB)</span>
            </div>
            <span class="claude-status">
              <span v-if="isInitializingClaude">ğŸ”„ åˆå§‹åŒ–ä¸­...</span>
              <span v-else-if="isClaudeInitialized">âœ… Claudeå·²å°±ç»ª</span>
              <span v-else>âšª Claudeæœªåˆå§‹åŒ–</span>
            </span>
          </div>
        </div>
        <div class="terminal-content" ref="terminalContainer" v-show="showTerminal">
          <!-- Terminal will be mounted here -->
        </div>
      </div>
    </div>

    <!-- Right Sidebar - Style Templates & Input -->
    <div class="right-sidebar">
      <!-- Top: Style Templates -->
      <div class="style-templates">
        <div class="template-header">é£æ ¼æ¨¡æ¿</div>
        <div class="template-list">
          <div 
            v-for="(template, index) in templates" 
            :key="index"
            class="template-item"
            :class="{ active: selectedTemplate === index }"
            @click="selectTemplate(index)"
          >
            <div class="template-name">{{ template.name }}</div>
            <div class="template-desc">{{ template.description }}</div>
          </div>
        </div>
      </div>

      <!-- Bottom: Input & Create -->
      <div class="input-create-section">
        <div class="input-wrapper">
          <input 
            v-model="currentTopic"
            type="text"
            class="topic-input"
            placeholder="è¾“å…¥ä¸»é¢˜"
          />
          <button 
            class="create-btn"
            @click="generateCard"
            :disabled="!currentTopic.trim() || isGenerating"
          >
            åˆ›å»º
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, nextTick } from 'vue'
import { ElMessage, ElMessageBox } from 'element-plus'
import { Terminal } from 'xterm'
import { FitAddon } from 'xterm-addon-fit'
import 'xterm/css/xterm.css'
import terminalAPI from '../api/terminal'
import terminalService from '../services/terminalService'
import cardGeneratorAPI from '../api/cardGenerator'
import MarkdownRenderer from '../components/MarkdownRenderer.vue'
import SimpleJsonViewer from '../components/SimpleJsonViewer.vue'
import ValidatedJsonViewer from '../components/ValidatedJsonViewer.vue'

// State
const currentTopic = ref('')
const generatedUrl = ref('')
const isGenerating = ref(false)
const selectedTemplate = ref(0)
const selectedCard = ref(null)
const selectedFolder = ref(null)
const terminalContainer = ref(null)
const terminal = ref(null)
const fitAddon = ref(null)
const cardFolders = ref([])
const templates = ref([])
const expandedFolders = ref([])
const isClaudeInitialized = ref(false)
const isInitializingClaude = ref(false)
const streamingStatus = ref({
  isStreaming: false,
  bufferLength: 0
})
const previewContent = ref('')
const previewType = ref('')
const isGeneratingHtml = ref({})
const showTerminal = ref(false) // Terminalé»˜è®¤éšè—

// Methods
// Initialize Claude in terminal
const initializeClaude = async () => {
  if (isInitializingClaude.value || isClaudeInitialized.value) return
  
  isInitializingClaude.value = true
  
  try {
    ElMessage.info('æ­£åœ¨åˆå§‹åŒ– Claude...')
    
    // Connect to terminal if not connected
    if (!terminalService.isReady()) {
      // Terminalä¼šåœ¨initializeXTermä¸­åˆå§‹åŒ–
      console.log('[Claude Init] Terminal not ready, waiting...')
      await new Promise(resolve => setTimeout(resolve, 1000))
    }
    
    // Send claude command with skip permissions flag (skips confirmation menu)
    console.log('[Claude Init] Sending claude command with --dangerously-skip-permissions')
    terminalService.sendCommand('claude --dangerously-skip-permissions')
    terminalService.sendInput('\r')  // Send Enter separately
    
    // Wait for Claude to initialize (no menu with --dangerously-skip-permissions)
    console.log('[Claude Init] Waiting for Claude to initialize...')
    await new Promise(resolve => setTimeout(resolve, 3000))
    
    // Check if Claude is ready by looking for prompt indicators
    const isReady = await terminalService.checkOutput(/claude>|â•­â”€|â–Œ/)
    
    if (isReady) {
      console.log('[Claude Init] Claude is ready')
    } else {
      console.log('[Claude Init] Claude initialization may still be in progress')
    }
    
    isClaudeInitialized.value = true
    ElMessage.success('Claude åˆå§‹åŒ–æˆåŠŸï¼')
    
  } catch (error) {
    console.error('[Claude Init] Error:', error)
    ElMessage.error('Claude åˆå§‹åŒ–å¤±è´¥: ' + error.message)
  } finally {
    isInitializingClaude.value = false
  }
}

const generateCard = async () => {
  if (!currentTopic.value.trim() || isGenerating.value) return
  
  // Check if Claude is initialized
  if (!isClaudeInitialized.value) {
    ElMessage.warning('è¯·å…ˆåˆå§‹åŒ– Claude')
    return
  }
  
  // Check if template is selected
  if (selectedTemplate.value === null || !templates.value[selectedTemplate.value]) {
    ElMessage.warning('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ¨¡æ¿')
    return
  }
  
  isGenerating.value = true
  
  try {
    // Get selected template info
    const template = templates.value[selectedTemplate.value]
    const templateFileName = template.fileName || 'daily-knowledge-card-template.md'
    // æ¨¡æ¿æ–‡ä»¶çš„å®Œæ•´è·¯å¾„
    const templatePath = `/mnt/d/work/AI_Terminal/terminal-backend/data/public_template/${templateFileName}`
    
    // æ„å»ºç”¨æˆ·å¡ç‰‡ç›®å½•è·¯å¾„ï¼ˆä½¿ç”¨ç»å¯¹è·¯å¾„ï¼‰
    const sanitizedTopic = currentTopic.value.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '_')
    // ä½¿ç”¨ç»å¯¹è·¯å¾„ç¡®ä¿æ–‡ä»¶åˆ›å»ºåœ¨æ­£ç¡®ä½ç½®
    const userCardPath = `/mnt/d/work/AI_Terminal/terminal-backend/data/users/default/folders/default-folder/cards/${sanitizedTopic}`
    
    // æ„å»ºå®Œæ•´çš„å‘½ä»¤ï¼Œä½¿ç”¨å®Œæ•´è·¯å¾„
    const prompt = `æ ¹æ®[${templatePath}]æ–‡æ¡£çš„è§„èŒƒï¼Œå°±ä»¥ä¸‹å‘½é¢˜ï¼Œç”Ÿæˆä¸€ç»„å¡ç‰‡çš„jsonæ–‡æ¡£åœ¨[${userCardPath}]ï¼š${currentTopic.value}`
    
    ElMessage.info('æ­£åœ¨ç”Ÿæˆå¡ç‰‡...')
    console.log('[Generate Card] Sending prompt:', prompt)
    
    // ä½¿ç”¨åˆ†ç¦»å‘é€æ–¹å¼ï¼šå…ˆå‘é€æ–‡æœ¬å†…å®¹ï¼Œç­‰å¾…ç»ˆç«¯å‡†å¤‡å¥½ï¼Œå†å‘é€æ§åˆ¶ç¬¦
    await terminalService.sendTextAndControl(prompt, '\r', 1000)
    
    // æ˜¾ç¤ºç”Ÿæˆä¿¡æ¯
    previewType.value = 'html'
    previewContent.value = `data:text/html,
      <div style="padding: 20px; font-family: Arial;">
        <h2>å¡ç‰‡ç”Ÿæˆä»»åŠ¡å·²æäº¤</h2>
        <p><strong>ä¸»é¢˜:</strong> ${currentTopic.value}</p>
        <p><strong>æ¨¡æ¿:</strong> ${templateFileName}</p>
        <p><strong>è¾“å‡ºè·¯å¾„:</strong> ${userCardPath}</p>
        <p style="color: #666;">ç»ˆç«¯æ­£åœ¨æ‰§è¡Œç”Ÿæˆä»»åŠ¡ï¼Œè¯·æŸ¥çœ‹ä¸‹æ–¹ç»ˆç«¯è¾“å‡º</p>
      </div>`
    
    ElMessage.success('ç”Ÿæˆå‘½ä»¤å·²å‘é€ï¼')
    
    // ç­‰å¾…å‡ ç§’åè‡ªåŠ¨åˆ·æ–°æ–‡ä»¶å¤¹åˆ—è¡¨
    setTimeout(async () => {
      await refreshCardFolders()
    }, 5000)
    
  } catch (error) {
    console.error('Generate card error:', error)
    ElMessage.error('ç”Ÿæˆå¤±è´¥: ' + error.message)
  } finally {
    isGenerating.value = false
  }
}

// Initialize XTerm
const initializeXTerm = async () => {
  if (!terminalContainer.value) return
  
  try {
    // ä½¿ç”¨ç»Ÿä¸€çš„terminalServiceåˆå§‹åŒ–
    await terminalService.init(terminalContainer.value, {
      cols: 120,
      rows: 30
    })
    
    console.log('[Terminal] Initialized successfully')
    
    // Terminalå·²ç»åœ¨serviceä¸­åˆ›å»ºï¼Œä¸éœ€è¦å†åˆ›å»º
    return
  } catch (error) {
    console.error('[Terminal] Failed to initialize:', error)
    ElMessage.error('ç»ˆç«¯åˆå§‹åŒ–å¤±è´¥: ' + error.message)
    return
  }
    theme: {
      background: '#0c0c0c',
      foreground: '#d0d0d0',
      cursor: '#d0d0d0',
      black: '#000000',
      red: '#cd3131',
      green: '#0dbc79',
      yellow: '#e5e510',
      blue: '#2472c8',
      magenta: '#bc3fbc',
      cyan: '#11a8cd',
      white: '#e5e5e5',
      brightBlack: '#666666',
      brightRed: '#f14c4c',
      brightGreen: '#23d18b',
      brightYellow: '#f5f543',
      brightBlue: '#3b8eea',
      brightMagenta: '#d670d6',
      brightCyan: '#29b8db',
      brightWhite: '#e5e5e5'
    },
    fontSize: 14,
    fontFamily: 'Menlo, Monaco, "Courier New", monospace',
    cursorBlink: true,
    scrollback: 10000,
    cols: 120,
    rows: 24,
    letterSpacing: 0,
    lineHeight: 1.2,
    convertEol: true,  // è½¬æ¢è¡Œç»“æŸç¬¦
    windowsMode: false, // ç¡®ä¿ä½¿ç”¨Unixæ¨¡å¼
    macOptionIsMeta: true,
    rendererType: 'canvas'  // ä½¿ç”¨canvasæ¸²æŸ“å™¨ä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½
  })
  
  // Add fit addon
  fitAddon.value = new FitAddon()
  terminal.value.loadAddon(fitAddon.value)
  
  // Mount terminal to DOM
  terminal.value.open(terminalContainer.value)
  fitAddon.value.fit()
  
  // Connect to backend via terminalIntegration
  await terminalIntegration.connect()
  
  // Handle terminal output from backend with optimized streaming
  let currentProgressLine = null
  let lastUpdateTime = 0
  let outputBuffer = []
  let flushTimer = null
  
  // æ‰¹é‡åˆ·æ–°å‡½æ•°
  const flushBuffer = () => {
    if (outputBuffer.length > 0 && terminal.value) {
      const combined = outputBuffer.join('')
      outputBuffer = []
      terminal.value.write(combined)
    }
    flushTimer = null
  }
  
  terminalIntegration.onOutput((data) => {
    if (!terminal.value) return
    
    const now = Date.now()
    
    // æ£€æµ‹æ˜¯å¦æ˜¯è¿›åº¦/åŠ¨ç”»è¡Œï¼ˆåŒ…å«ç‰¹æ®Šå­—ç¬¦å’ŒçŠ¶æ€ä¿¡æ¯ï¼‰
    const isProgressUpdate = /[âœ»âœ¶âœ½âœ¢Â·âœ¤âœ§â˜…â˜†â–ªâ–«â—†â—‡â—‹â—â–¡â– ].*(?:tokens|interrupt|â€¦)/i.test(data)
    
    // æ£€æµ‹æ˜¯å¦æ˜¯æ¡†æ¶çº¿
    const isFrameLine = /^[â•­â”€â”¬â•®â”‚â”œâ”€â”¼â”¤â•°â”€â”´â•¯]+/.test(data.trim())
    
    if (isProgressUpdate) {
      // è¿›åº¦æ›´æ–°ï¼šè¦†ç›–å½“å‰è¡Œ
      if (currentProgressLine !== null) {
        // ç§»åŠ¨åˆ°è¿›åº¦è¡Œå¹¶æ¸…é™¤
        terminal.value.write('\x1b[1A')  // ä¸Šç§»ä¸€è¡Œ
        terminal.value.write('\r\x1b[2K') // æ¸…é™¤æ•´è¡Œ
      }
      
      // å†™å…¥æ–°çš„è¿›åº¦ä¿¡æ¯ï¼ˆå»æ‰å¤šä½™çš„æ¢è¡Œå’Œæ¡†æ¶ï¼‰
      const cleanData = data
        .replace(/[\r\n]+/g, '')  // ç§»é™¤æ‰€æœ‰æ¢è¡Œ
        .replace(/[â•­â”€â”¬â•®â”‚â”œâ”€â”¼â”¤â•°â”€â”´â•¯]+/g, '') // ç§»é™¤æ¡†æ¶å­—ç¬¦
        .trim()
      
      if (cleanData) {
        terminal.value.write(cleanData)
        currentProgressLine = cleanData
      }
      
      lastUpdateTime = now
      
    } else if (isFrameLine && now - lastUpdateTime < 100) {
      // å¿½ç•¥ç´§éšè¿›åº¦æ›´æ–°åçš„æ¡†æ¶çº¿ï¼ˆ100mså†…ï¼‰
      return
      
    } else if (data.includes('â”‚') && data.includes('tokens')) {
      // å¤„ç†å¸¦æ¡†æ¶çš„è¿›åº¦è¡Œ
      const match = data.match(/([âœ»âœ¶âœ½âœ¢Â·âœ¤âœ§â˜…â˜†â–ªâ–«â—†â—‡â—‹â—â–¡â– ].*?(?:tokens|interrupt|â€¦)[^â”‚]*)/i)
      if (match) {
        if (currentProgressLine !== null) {
          terminal.value.write('\x1b[1A\r\x1b[2K')
        }
        terminal.value.write(match[1].trim())
        currentProgressLine = match[1].trim()
      }
      
    } else {
      // æ­£å¸¸è¾“å‡º
      if (currentProgressLine !== null && !data.match(/^\s*$/)) {
        // å¦‚æœä¹‹å‰æœ‰è¿›åº¦è¡Œï¼Œå…ˆæ¢è¡Œ
        terminal.value.write('\n')
        currentProgressLine = null
      }
      
      // æ‰¹é‡ç¼“å†²æ™®é€šè¾“å‡º
      outputBuffer.push(data)
      
      // ä½¿ç”¨requestAnimationFrameæˆ–å®šæ—¶å™¨æ‰¹é‡åˆ·æ–°
      if (!flushTimer) {
        flushTimer = setTimeout(flushBuffer, 10)
      }
    }
  })
  
  // Send input to backend
  terminal.value.onData((data) => {
    terminalIntegration.sendInput(data)
  })
  
  // Handle window resize
  window.addEventListener('resize', () => {
    if (fitAddon.value) {
      fitAddon.value.fit()
    }
  })
}

// Select template
const selectTemplate = (index) => {
  selectedTemplate.value = index
  console.log('Selected template:', templates.value[index])
}

// Toggle folder expand/collapse
const toggleFolder = (folderId) => {
  const index = expandedFolders.value.indexOf(folderId)
  if (index > -1) {
    expandedFolders.value.splice(index, 1)
  } else {
    expandedFolders.value.push(folderId)
  }
}

// Select a card
const selectCard = (cardId, folderId) => {
  selectedCard.value = cardId
  selectedFolder.value = folderId
  // Load card content if needed
  loadCardContent(cardId, folderId)
}

// Load card content
const loadCardContent = async (cardId, folderId) => {
  try {
    // æ‰¾åˆ°å¯¹åº”çš„å¡ç‰‡
    const folder = cardFolders.value.find(f => f.id === folderId)
    if (!folder) return
    
    const card = folder.cards.find(c => c.id === cardId)
    if (!card) return
    
    console.log('[CardContent] Loading card:', card.name, 'path:', card.path)
    
    // æ ¹æ®æ–‡ä»¶æ‰©å±•åç¡®å®šé¢„è§ˆç±»å‹
    const fileName = card.name.toLowerCase()
    if (fileName.endsWith('.html') || fileName.endsWith('.htm')) {
      previewType.value = 'html'
      // HTMLæ–‡ä»¶ï¼šä½¿ç”¨åç«¯é™æ€æœåŠ¡URL
      const baseUrl = 'http://localhost:3000'
      previewContent.value = `${baseUrl}/api/terminal/card/html/${folder.id}/${encodeURIComponent(card.name)}`
      console.log('[CardContent] HTML file URL:', previewContent.value)
    } else if (fileName.endsWith('.json')) {
      previewType.value = 'json'
      // JSONæ–‡ä»¶ï¼šå°è¯•è¯»å–æ–‡ä»¶å†…å®¹
      try {
        console.log('[CardContent] Attempting to load JSON content from:', card.path)
        // ä½¿ç”¨åç«¯APIè¯»å–å¡ç‰‡å†…å®¹
        const response = await terminalAPI.getCardContent(card.path)
        if (response && response.success) {
          previewContent.value = response.content
        } else {
          // å¦‚æœAPIå¤±è´¥ï¼Œæ˜¾ç¤ºå¡ç‰‡ä¿¡æ¯
          previewContent.value = {
            title: card.name,
            path: card.path,
            folder: folder.name,
            loadTime: new Date().toISOString(),
            note: "æ— æ³•åŠ è½½æ–‡ä»¶å†…å®¹ï¼Œæ˜¾ç¤ºå¡ç‰‡å…ƒä¿¡æ¯"
          }
        }
      } catch (error) {
        console.error('[CardContent] Failed to load JSON content:', error)
        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯å’ŒåŸºæœ¬å¡ç‰‡æ•°æ®
        previewContent.value = {
          title: card.name,
          path: card.path,
          folder: folder.name,
          error: "æ–‡ä»¶è¯»å–å¤±è´¥: " + error.message,
          loadTime: new Date().toISOString()
        }
      }
    } else {
      // å…¶ä»–ç±»å‹æ–‡ä»¶ï¼šæ˜¾ç¤ºåŸºæœ¬ä¿¡æ¯
      previewType.value = 'html'
      previewContent.value = `data:text/html;charset=utf-8,
        <div style="padding: 20px; font-family: Arial, sans-serif; background: #f5f5f5; height: 100%;">
          <h2 style="color: #333; margin-bottom: 20px;">ğŸ“„ ${card.name}</h2>
          <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <p style="color: #666; margin-bottom: 15px;">
              <strong>æ–‡ä»¶è·¯å¾„:</strong><br/>
              <code style="background: #f0f0f0; padding: 5px; border-radius: 3px; font-size: 12px; word-break: break-all;">
                ${card.path || 'N/A'}
              </code>
            </p>
            <p style="color: #666; margin-bottom: 15px;">
              <strong>ä¸»é¢˜:</strong> ${folder.name}
            </p>
            <p style="color: #666; margin-bottom: 15px;">
              <strong>ç±»å‹:</strong> ${fileName.split('.').pop().toUpperCase()}æ–‡ä»¶
            </p>
            <div style="margin-top: 20px; padding: 15px; background: #f9f9f9; border-left: 3px solid #4a9eff;">
              <p style="color: #999; font-size: 14px;">
                ğŸ’¡ è¯¥æ–‡ä»¶ç”±Claude AIæ ¹æ®æ¨¡æ¿ç”Ÿæˆ<br/>
                æš‚ä¸æ”¯æŒæ­¤æ–‡ä»¶ç±»å‹çš„é¢„è§ˆ
              </p>
            </div>
          </div>
          <div style="margin-top: 20px; text-align: center;">
            <span style="color: #999; font-size: 12px;">åŠ è½½æ—¶é—´: ${new Date().toLocaleString()}</span>
          </div>
        </div>`
    }
    
    ElMessage.success('å¡ç‰‡åŠ è½½æˆåŠŸ')
  } catch (error) {
    console.error('[CardContent] Failed to load card content:', error)
    ElMessage.error('åŠ è½½å¡ç‰‡å¤±è´¥: ' + error.message)
  }
}

// Handle JSON fixed event
const handleJsonFixed = (fixedData) => {
  console.log('[CardGenerator] JSON data fixed:', fixedData)
  previewContent.value = fixedData
  ElMessage.success('JSONæ ¼å¼å·²ä¿®å¤')
}

// Handle JSON preview event
const handleJsonPreview = (jsonData) => {
  console.log('[CardGenerator] Preview JSON as card:', jsonData)
  // å¯ä»¥åœ¨è¿™é‡Œå®ç°é¢„è§ˆåŠŸèƒ½
  ElMessage.info('é¢„è§ˆåŠŸèƒ½å¼€å‘ä¸­...')
}

// Download HTML locally using browser
const downloadHtmlLocally = (htmlContent, fileName, url = null) => {
  try {
    if (htmlContent) {
      // å¦‚æœæœ‰å†…å®¹ï¼Œç›´æ¥ä¸‹è½½
      const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' })
      const downloadUrl = URL.createObjectURL(blob)
      const link = document.createElement('a')
      link.href = downloadUrl
      link.download = fileName
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
      URL.revokeObjectURL(downloadUrl)
      
      console.log('[GenerateHTML] HTML downloaded locally via browser:', fileName)
      ElMessage.success(`HTMLæ–‡ä»¶å·²ä¸‹è½½åˆ°æµè§ˆå™¨é»˜è®¤ä¸‹è½½ç›®å½•ï¼š${fileName}`)
    } else if (url) {
      // å¦‚æœæ²¡æœ‰å†…å®¹ä½†æœ‰URLï¼Œè§¦å‘æµè§ˆå™¨ä¸‹è½½
      const link = document.createElement('a')
      link.href = url
      link.download = fileName
      link.target = '_blank'
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
      
      console.log('[GenerateHTML] Triggered browser download from URL:', url)
      ElMessage.info('å·²è§¦å‘æµè§ˆå™¨ä¸‹è½½ï¼Œè¯·æŸ¥çœ‹ä¸‹è½½ç›®å½•')
    }
  } catch (error) {
    console.error('[GenerateHTML] Failed to download locally:', error)
    ElMessage.error('æœ¬åœ°ä¸‹è½½å¤±è´¥: ' + error.message)
  }
}

// Generate HTML from JSON file and preview
const generateHtmlFromJson = async (card, folder) => {
  try {
    // è®¾ç½®ç”ŸæˆçŠ¶æ€
    isGeneratingHtml.value[card.id] = true
    
    console.log('[GenerateHTML] Processing card:', card.name, 'from folder:', folder.name)
    
    // æ˜¾ç¤ºåŠ è½½æç¤º
    ElMessage.info('æ­£åœ¨ç”Ÿæˆé¢„è§ˆé“¾æ¥...')
    
    // è¯»å–JSONæ–‡ä»¶å†…å®¹
    let jsonContent = null
    try {
      const response = await terminalAPI.getCardContent(card.path)
      if (response && response.success) {
        jsonContent = response.content
      } else {
        throw new Error('æ— æ³•è¯»å–JSONæ–‡ä»¶å†…å®¹')
      }
    } catch (error) {
      console.error('[GenerateHTML] Failed to read JSON file:', error)
      throw new Error('è¯»å–JSONæ–‡ä»¶å¤±è´¥: ' + error.message)
    }
    
    console.log('[GenerateHTML] JSON content loaded:', jsonContent)
    
    // è°ƒç”¨APIç”ŸæˆHTML
    const generateResult = await cardGeneratorAPI.generateHtmlCard(jsonContent)
    
    if (!generateResult.success) {
      throw new Error(generateResult.error || 'ç”ŸæˆHTMLå¤±è´¥')
    }
    
    console.log('[GenerateHTML] HTML generated successfully:', generateResult.data)
    
    // è·å–åˆ†äº«é“¾æ¥å¹¶æ›¿æ¢åŸŸå
    let shareUrl = generateResult.data.shareLink
    
    // æ›¿æ¢åŸŸå: engagia-s-cdmxfcdbwa.cn-hangzhou.fcapp.run -> engagia-s3.paitongai.net
    shareUrl = shareUrl.replace(
      'engagia-s-cdmxfcdbwa.cn-hangzhou.fcapp.run',
      'engagia-s3.paitongai.net'
    )
    
    console.log('[GenerateHTML] Share URL with new domain:', shareUrl)
    
    // ç›´æ¥åœ¨iframeä¸­åŠ è½½é¢„è§ˆ
    previewType.value = 'iframe'
    previewContent.value = shareUrl
    
    // é€‰ä¸­å½“å‰å¡ç‰‡
    selectedCard.value = card.id
    
    ElMessage.success('é¢„è§ˆé“¾æ¥å·²ç”Ÿæˆï¼')
    
    // å¯é€‰ï¼šå¤åˆ¶é“¾æ¥åˆ°å‰ªè´´æ¿
    if (navigator.clipboard) {
      navigator.clipboard.writeText(shareUrl).then(() => {
        console.log('[GenerateHTML] Share link copied to clipboard:', shareUrl)
      }).catch(err => {
        console.error('[GenerateHTML] Failed to copy link:', err)
      })
    }
    
  } catch (error) {
    console.error('[GenerateHTML] Error:', error)
    ElMessage.error('ç”Ÿæˆé¢„è§ˆå¤±è´¥: ' + error.message)
  } finally {
    // æ¸…é™¤ç”ŸæˆçŠ¶æ€
    isGeneratingHtml.value[card.id] = false
  }
}


// Get file icon based on extension
const getFileIcon = (fileName) => {
  const ext = fileName.toLowerCase().split('.').pop()
  switch (ext) {
    case 'json':
      return 'ğŸ“‹'
    case 'html':
    case 'htm':
      return 'ğŸŒ'
    default:
      return 'ğŸ“„'
  }
}

// Get file type display text
const getFileType = (fileName) => {
  const ext = fileName.toLowerCase().split('.').pop()
  switch (ext) {
    case 'json':
      return 'JSON'
    case 'html':
    case 'htm':
      return 'HTML'
    default:
      return ext.toUpperCase()
  }
}

// Load user card folders from file system
const loadCardFolders = async () => {
  try {
    // è°ƒç”¨åç«¯APIè·å–çœŸå®çš„ç›®å½•ç»“æ„
    const response = await terminalAPI.getCardsDirectory()
    if (response && response.success && response.folders) {
      cardFolders.value = response.folders
      // Auto-expand first folder
      if (cardFolders.value.length > 0 && !expandedFolders.value.includes(cardFolders.value[0].id)) {
        expandedFolders.value.push(cardFolders.value[0].id)
      }
      console.log('Loaded folders from backend:', cardFolders.value)
      return
    }
  } catch (error) {
    console.error('Failed to load folders from backend:', error)
  }
  
  // å¦‚æœAPIå¤±è´¥ï¼Œè‡³å°‘æ˜¾ç¤ºç©ºçŠ¶æ€
  if (!cardFolders.value) {
    cardFolders.value = []
  }
}

// åˆ·æ–°å¡ç‰‡æ–‡ä»¶å¤¹ï¼ˆç”Ÿæˆåè°ƒç”¨ï¼‰
const refreshCardFolders = async () => {
  // æ¨¡æ‹Ÿè¯»å–ç”Ÿæˆçš„æ–‡ä»¶
  const generatedTopic = currentTopic.value
  if (generatedTopic) {
    const sanitizedTopic = generatedTopic.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '_')
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¯¥æ–‡ä»¶å¤¹
    const existingFolder = cardFolders.value.find(f => f.id === sanitizedTopic)
    
    if (!existingFolder) {
      // æ·»åŠ æ–°çš„æ–‡ä»¶å¤¹å’Œæ–‡ä»¶
      cardFolders.value.push({
        id: sanitizedTopic,
        name: generatedTopic,
        cards: [
          { 
            id: `${sanitizedTopic}-1`, 
            name: `${sanitizedTopic}-knowledge-card.json`,
            path: `/mnt/d/work/AI_Terminal/terminal-backend/data/users/default/folders/default-folder/cards/${sanitizedTopic}/${sanitizedTopic}-knowledge-card.json`
          }
        ]
      })
      
      // è‡ªåŠ¨å±•å¼€æ–°æ–‡ä»¶å¤¹
      expandedFolders.value.push(sanitizedTopic)
    } else {
      // å¦‚æœæ–‡ä»¶å¤¹å·²å­˜åœ¨ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦æ·»åŠ æ–°æ–‡ä»¶
      const newCard = { 
        id: `${sanitizedTopic}-${Date.now()}`, 
        name: `${sanitizedTopic}-knowledge-card.json`,
        path: `/mnt/d/work/AI_Terminal/terminal-backend/data/users/default/folders/default-folder/cards/${sanitizedTopic}/${sanitizedTopic}-knowledge-card.json`
      }
      
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
      const exists = existingFolder.cards.some(c => c.name === newCard.name)
      if (!exists) {
        existingFolder.cards.push(newCard)
      }
    }
  }
  
  // ä¿å­˜åˆ°localStorageä»¥ä¾¿ä¸‹æ¬¡åŠ è½½
  localStorage.setItem('generatedCardFolders', JSON.stringify(cardFolders.value))
  
  ElMessage.success('æ–‡ä»¶å¤¹å·²åˆ·æ–°')
}

// Load templates
const loadTemplates = async () => {
  try {
    const response = await terminalAPI.getTemplates()
    if (response.success && response.templates) {
      templates.value = response.templates
    } else {
      // Fallback templates based on the file we read
      templates.value = [
        {
          name: 'æ¯æ—¥çŸ¥è¯†å¡ç‰‡',
          description: 'ç§‘æ™®å‘å†…å®¹ï¼Œé€‚åˆçŸ¥è¯†åˆ†äº«',
          fileName: 'daily-knowledge-card-template.md'
        },
        {
          name: 'AIçŸ¥è¯†ç³»åˆ—',
          description: 'äººå·¥æ™ºèƒ½ç›¸å…³çŸ¥è¯†ç§‘æ™®',
          fileName: 'ai-knowledge-series-template.md'
        },
        {
          name: 'å¿ƒç†å­¦çŸ¥è¯†',
          description: 'å¿ƒç†å­¦æ¦‚å¿µå’Œæ—¥å¸¸åº”ç”¨',
          fileName: 'psychology-knowledge-template.md'
        }
      ]
    }
  } catch (error) {
    console.error('Failed to load templates:', error)
    // Use fallback templates
    templates.value = [
      {
        name: 'æ¯æ—¥çŸ¥è¯†å¡ç‰‡',
        description: 'ç§‘æ™®å‘å†…å®¹ï¼Œé€‚åˆçŸ¥è¯†åˆ†äº«',
        fileName: 'daily-knowledge-card-template.md'
      },
      {
        name: 'AIçŸ¥è¯†ç³»åˆ—',
        description: 'äººå·¥æ™ºèƒ½ç›¸å…³çŸ¥è¯†ç§‘æ™®',
        fileName: 'ai-knowledge-series-template.md'
      }
    ]
  }
}

// Initialize
onMounted(async () => {
  // Load data
  loadCardFolders()
  loadTemplates()
  
  // Initialize terminal after DOM is ready
  await nextTick()
  initializeXTerm()
  
  // ç›‘å¬æµå¼çŠ¶æ€å˜åŒ–
  setInterval(() => {
    if (terminalIntegration.getStreamingStatus) {
      const status = terminalIntegration.getStreamingStatus()
      streamingStatus.value = status
    }
  }, 500)
  
  // è‡ªåŠ¨åˆå§‹åŒ–Claudeï¼ˆå»¶è¿Ÿ2ç§’ç¡®ä¿terminalå‡†å¤‡å°±ç»ªï¼‰
  setTimeout(() => {
    console.log('[CardGenerator] Auto-initializing Claude...')
    initializeClaude()
  }, 2000)
})
</script>

<style scoped>
.card-generator-layout {
  display: flex;
  height: 100vh;
  width: 100vw;
  background: #1a1a1a;
  color: #e0e0e0;
  font-family: 'Microsoft YaHei', sans-serif;
  overflow: hidden;  /* é˜²æ­¢æ»šåŠ¨æ¡ */
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

/* Left Sidebar */
.left-sidebar {
  width: 240px;
  min-width: 240px;
  flex-shrink: 0;
  background: #1e1e1e;
  border-right: 1px solid #2d2d2d;
  padding: 0;
  display: flex;
  flex-direction: column;
}

.sidebar-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid #2d2d2d;
  background: #252525;
}

.sidebar-title {
  font-size: 13px;
  font-weight: 600;
  color: #cccccc;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.refresh-btn {
  background: transparent;
  border: none;
  color: #888;
  padding: 4px;
  border-radius: 3px;
  cursor: pointer;
  font-size: 16px;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
}

.refresh-btn:hover {
  background: #2a2a2a;
  color: #4a9eff;
}

.folder-tree {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.folder-tree::-webkit-scrollbar {
  width: 6px;
}

.folder-tree::-webkit-scrollbar-track {
  background: transparent;
}

.folder-tree::-webkit-scrollbar-thumb {
  background: #444;
  border-radius: 3px;
}

.folder-tree::-webkit-scrollbar-thumb:hover {
  background: #555;
}

.folder-container {
  display: flex;
  flex-direction: column;
}

.folder-item {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 8px;
  background: transparent;
  border-radius: 3px;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 14px;
  user-select: none;
  margin-bottom: 2px;
}

.folder-item:hover {
  background: #2a2a2a;
}

.folder-item.expanded {
  background: transparent;
}

.folder-icon {
  font-size: 14px;
  width: 18px;
  text-align: center;
  flex-shrink: 0;
}

.folder-name {
  flex: 1;
  color: #e0e0e0;
  font-weight: 500;
}

.folder-count {
  color: #666;
  font-size: 11px;
  background: #2a2a2a;
  padding: 1px 5px;
  border-radius: 10px;
}

.cards-list {
  margin-left: 22px;
  margin-top: 4px;
  display: flex;
  flex-direction: column;
  gap: 1px;
}

.card-item {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 5px 8px;
  background: transparent;
  border-radius: 3px;
  transition: all 0.2s;
  font-size: 13px;
  cursor: pointer;
  position: relative;
}

.card-item:hover {
  background: #2a2a2a;
}

.card-item.active {
  background: #2a2a2a;
}

.card-item.active::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 2px;
  background: #4a9eff;
  border-radius: 2px;
}

.card-icon {
  font-size: 14px;
  width: 18px;
  text-align: center;
  flex-shrink: 0;
}

.card-name {
  color: #d0d0d0;
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  min-width: 0;
}

.card-actions {
  display: flex;
  align-items: center;
  gap: 6px;
  flex-shrink: 0;
}

.card-type {
  color: #888;
  font-size: 10px;
  padding: 2px 5px;
  background: transparent;
  border: 1px solid #444;
  border-radius: 3px;
  text-transform: uppercase;
  line-height: 1;
}

.generate-html-btn {
  background: transparent;
  color: #4a9eff;
  border: 1px solid #4a9eff;
  border-radius: 3px;
  padding: 2px 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  height: 20px;
  width: 20px;
  opacity: 0;
}

.card-item:hover .generate-html-btn {
  opacity: 1;
}

.generate-html-btn:hover {
  background: #4a9eff;
  color: white;
}

.generate-html-btn:active {
  transform: scale(0.95);
}

.generate-html-btn:disabled {
  background: transparent;
  border-color: #555;
  color: #555;
  cursor: not-allowed;
}

.loading-spinner {
  animation: spin 1s linear infinite;
  display: inline-block;
  font-size: 14px;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.empty-message {
  text-align: center;
  color: #666;
  padding: 20px;
  font-size: 13px;
}

/* Main Area */
.main-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  padding: 20px;
  gap: 20px;
  min-width: 0; /* é˜²æ­¢flexå­å…ƒç´ æ’‘å¼€ */
  max-width: calc(100vw - 560px); /* å·¦ä¾§240px + å³ä¾§320px */
}

.preview-area,
.terminal-area {
  background: #252525;
  border: 1px solid #333;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.preview-area {
  flex: 1;
}

.terminal-area {
  height: 300px;
  transition: height 0.3s ease;
}

.terminal-area.collapsed {
  height: 48px; /* åªæ˜¾ç¤ºheader */
}

.area-title {
  padding: 12px 20px;
  background: #2a2a2a;
  border-bottom: 1px solid #333;
  font-size: 14px;
  font-weight: 500;
  text-align: center;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
}

.preview-type-tag {
  background: #4a9eff;
  color: white;
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 10px;
  font-weight: bold;
}

.terminal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 20px;
  background: #2a2a2a;
  border-bottom: 1px solid #333;
  cursor: pointer;
  user-select: none;
}

.terminal-header:hover {
  background: #303030;
}

.terminal-toggle {
  display: inline-block;
  margin-right: 8px;
  transition: transform 0.2s;
}

.terminal-status-mini {
  margin-left: 10px;
  font-size: 12px;
  color: #888;
}

.claude-status {
  font-size: 13px;
  color: #888;
}

.terminal-title {
  font-size: 14px;
  font-weight: 500;
}

.terminal-actions {
  display: flex;
  gap: 8px;
}

.init-claude-btn {
  padding: 6px 12px;
  background: #3a3a3a;
  color: #e0e0e0;
  border: 1px solid #444;
  border-radius: 4px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;
  white-space: nowrap;
}

.init-claude-btn:hover:not(:disabled) {
  background: #4a4a4a;
  border-color: #4a9eff;
}

.init-claude-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.preview-content {
  flex: 1;
  position: relative;
  overflow: hidden; /* é˜²æ­¢å†…å®¹æº¢å‡º */
  display: flex;
  flex-direction: column;
}

.json-viewer-preview {
  flex: 1;
  overflow: hidden;
}

.preview-iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: white;
  border: none;
}

.empty-state {
  color: #666;
  font-size: 14px;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
}

.json-viewer-preview {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
}

.terminal-content {
  flex: 1;
  background: #0c0c0c;
  overflow: hidden;
  padding: 10px;
  text-align: left;
}

/* XTerm container styles */
.terminal-content :deep(.xterm) {
  padding: 10px;
  height: 100%;
}

.terminal-content :deep(.xterm-viewport) {
  background-color: #0c0c0c;
}

.terminal-content :deep(.xterm-screen) {
  padding: 0;
  margin: 0;
}

.terminal-content :deep(.xterm-rows) {
  text-align: left !important;
  font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
}

/* Right Sidebar */
.right-sidebar {
  width: 320px;
  min-width: 320px;
  flex-shrink: 0;
  background: #252525;
  border-left: 1px solid #333;
  display: flex;
  flex-direction: column;
  position: relative;
}

/* Style Templates */
.style-templates {
  flex: 1;
  display: flex;
  flex-direction: column;
  border-bottom: 1px solid #333;
  overflow: hidden;
}

.template-header {
  padding: 15px 20px;
  background: #2a2a2a;
  border-bottom: 1px solid #333;
  font-size: 15px;
  font-weight: 500;
  color: #fff;
}

.template-list {
  flex: 1;
  overflow-y: auto;
  padding: 10px;
}

.template-item {
  padding: 12px 15px;
  margin-bottom: 8px;
  background: #2a2a2a;
  border: 1px solid #333;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
}

.template-item:hover {
  background: #333;
  border-color: #444;
}

.template-item.active {
  background: #3a3a3a;
  border-color: #4a9eff;
}

.template-name {
  font-size: 14px;
  font-weight: 500;
  color: #fff;
  margin-bottom: 4px;
}

.template-desc {
  font-size: 12px;
  color: #999;
  line-height: 1.4;
}

/* Input & Create Section */
.input-create-section {
  padding: 20px;
  background: #2a2a2a;
}

.input-wrapper {
  display: flex;
  gap: 10px;
}

.topic-input {
  flex: 1;
  padding: 10px 15px;
  background: #1a1a1a;
  border: 1px solid #444;
  border-radius: 4px;
  color: #e0e0e0;
  font-size: 14px;
}

.topic-input::placeholder {
  color: #666;
}

.topic-input:focus {
  outline: none;
  border-color: #4a9eff;
}

.create-btn {
  padding: 10px 30px;
  background: #4a9eff;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  cursor: pointer;
  transition: background 0.2s;
  font-weight: 500;
}

.create-btn:hover:not(:disabled) {
  background: #3a8eef;
}

.create-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* æµå¼çŠ¶æ€æŒ‡ç¤ºå™¨ */
.streaming-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  background: rgba(74, 158, 255, 0.1);
  border: 1px solid #4a9eff;
  border-radius: 4px;
  font-size: 12px;
  color: #4a9eff;
  animation: pulse 1.5s ease-in-out infinite;
}

.streaming-dot {
  width: 8px;
  height: 8px;
  background: #4a9eff;
  border-radius: 50%;
  animation: blink 1s infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 0.8;
  }
  50% {
    opacity: 1;
  }
}

@keyframes blink {
  0%, 50%, 100% {
    opacity: 1;
  }
  25%, 75% {
    opacity: 0.3;
  }
}

/* HTMLé“¾æ¥å¯¹è¯æ¡†æ ·å¼ */
:deep(.html-links-dialog) {
  .el-message-box__content {
    padding: 20px;
  }
  
  a {
    word-break: break-all;
    display: inline-block;
  }
  
  a:hover {
    text-decoration: underline;
  }
}
</style>